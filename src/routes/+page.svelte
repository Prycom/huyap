<script lang="ts">
	
</script>

<div class="flex w-full flex-col gap-4 p-6 lg:p-12">
	<h2 class="text-3xl font-bold">Теория</h2>

	<p>Существуют три основных способа задания языка:</p>
	<p>
		1. Перечисление всех допустимых цепочек языка (способ формальный, на практике нереализуем, т.к.
		в общем случае множество цепочек языка бесконечно и перечислить их невозможно).
	</p>
	<p>
		2. Указание способа порождения цепочек языка (задание грамматики языка) – применение т.н.
		генератора.
	</p>
	<p>3. Задание метода распознавания цепочек языка – использование распознавателя.</p>

	<p>
		Формально грамматика G определяется как четвёрка G(VT,VN,P,S)G(VT​,VN​,P,S), где: <br />VT​ –
		множество терминальных символов (символы алфавита языка); <br />VN​ – множество нетерминальных
		символов (вспомогательные символы, ими могут быть слова, понятия, конструкции языка);
		<br />причём множества терминальных и нетерминальных символов не пересекаются: VT∩VN=∅VT​∩VN​=∅;
		V=VT∪VNV=VT​∪VN​ – полный алфавит грамматики GG; <br />PP – множество правил вида α→βα→β, где
		α∈V+α∈V+, β∈V∗β∈V∗; S∈VNS∈VN​ – начальный (целевой) символ грамматики GG, с которого начинается
		процесс порождения цепочек языка.
	</p>
	<p>
		Нетерминальные символы участвуют в процессе порождения цепочек языка, но в окончательном виде
		цепочки языка состоят только из символов терминального алфавита.
	</p>
	<h3 class="mt-4 text-2xl font-semibold">Классификация грамматик по Хомскому:</h3>
	<p class="text-xl font-semibold">Тип 0 – грамматики с фразовой структурой, или без ограничений</p>
	<p>
		На структуру их правил не накладывается никаких ограничений, т.е. правила имеют вид: α→βα→β, где
		α∈V+α∈V+, β∈V∗β∈V∗. Это самый общий тип грамматик. Грамматики, которые относятся только к этому
		и не могут быть отнесены ни к какому другому типу, являются самыми сложными.
	</p>
	<p class="font-semibold">Пример грамматики типа 0</p>
	<div class="">
		Пусть у нас есть грамматика G(VT, VN, P, S), где:<br />

		VT = (a, b, c) - терминальные символы (или проще говоря используемый алфавит из которого мы
		составляем цепочки)<br />
		VN = (S, A, B) - нетерминальные символы (конструкции языка, необходимые для порождения цепочек, все
		эти символы будут меняться на буковы)<br />
		P - набор правил:<br />
		<div class="pl-8">
			S → AB<br />
			A → aA | a<br />
			B → bB | b<br />
			S → aB<br />
			A → Ba<br />
			S - начальный символ<br />
		</div>
		<p class="font-semibold">Цепочки, генерируемые этой грамматикой</p>
		Эта грамматика может генерировать следующие цепочки:
		<div class="pl-8">
			aab<br />
			abb<br />
			aabb<br />
			abab<br />
			...<br />
		</div>
		Основная сложность данной грамматики заключается в том, что могут генерироваться абсолютно разные
		цепочки, с трудными переплетениями символов и анализировать это добро неприятно
	</div>

	<h3 class="mt-4 text-2xl font-semibold">
		Тип 1 – <u>Контекстно-зависимые</u> (КЗ) и <u>неукорачивающие</u> грамматики
	</h3>
	К этому типу относятся два основных класса грамматик.<br />
	<strong>
		Контекстно-зависимые грамматики имеют правила вида<br />
	</strong>
	α1Aα2→α1βα2α1​Aα2​→α1​βα2​, где α1,α2∈V∗α1​,α2​∈V∗, A∈VNA∈VN​, β∈V+β∈V+.<br />
	<strong>
		Неукорачивающие грамматики имеют правила вида<br />
	</strong>
	α→βα→β, где α,β∈V+α,β∈V+, ∣β∣≥∣α∣∣β∣≥∣α∣.<br />
	<div class="card w-96 bg-base-200 p-4">
		<p class="card-title">Сложность контекста!</p>
		<div class="card-body">
			В КЗ-грамматиках при построении предложений заданного языка один и тот же нетерминальный
			символ может быть заменён различными терминальными цепочками в зависимости от контекста, в
			котором он встречается. Цепочки α1α1​ и α2α2​ в правилах обозначают контекст: α1α1​ – левый
			контекст, α2α2​ – правый контекст. В общем случае они могут быть пустыми.
		</div>
	</div>

	<p class="font-semibold">Пример КЗ-грамматики</p>
	Пусть у нас есть грамматика G(VT, VN, P, S), где:<br />
	VT = (a, b, c) - терминальные символы<br />
	VN = (S, A, B) - нетерминальные символы<br />
	P - набор правил:<br />
	<div class="pl-8">
		S → AB<br />
		A → aA | a<br />
		B → bB | b<br />
		bAa → bca<br />
		aAb → acb<br />
	</div>
	S - начальный символ<br />
	<p class="font-semibold">Объяснение</p>

	В этом примере грамматики правила имеют следующий вид:
	<pre>
	S → AB: заменяет начальный символ S на строку AB
	A → aA | a: заменяет символ A на строку aA или на символ a
	B → bB | b: заменяет символ B на строку bB или на символ b
	bAa → bca: заменяет строку bAa на строку bca
	aAb → acb: заменяет строку aAb на строку acb
	</pre>
	<p class="font-semibold">
		Пример неукорачивающей грамматики 
	</p>
	Пусть у нас есть грамматика G(VT, VN, P, S), где:
	<pre>
	VT = (a, b, c) - терминальные символы
	VN = (S, A, B) - нетерминальные символы
	P - набор правил:
    S → AB
    A → aA | aa
    B → bB | bb
	S - начальный символ
	</pre>
	<strong>Объяснение 
	</strong>
	В этом примере грамматики правила имеют следующий вид:
    <pre>
	S → AB: заменяет начальный символ S на строку AB
	A → aA | aa: заменяет символ A на строку aA или на строку aa
	B → bB | bb: заменяет символ B на строку bB или на строку bb
	</pre>
	То есть в данном случае мы заменяем нетерминальный символ, некоторой последовательностью, которая по длине не меньше этого терминала
	
	<h3 class="mt-4 text-2xl font-semibold">
		Тип 2 – <u>Контекстно-свободные</u> (КС) грамматики
	</h3>
	<strong>Отличие от предыдущих типов</strong> 
	КС-грамматики отличаются от предыдущих типов тем,<br />
	что левая часть правил должна состоять ровно из одного нетерминального символа.<br /> 
	Это означает, что мы не можем иметь правила вида αAβ → γ, где α и β - строки, <br />
	состоящие из терминальных и нетерминальных символов. <br />
	<strong>Укорачивающие КС-грамматики</strong> 
	Укорачивающие КС-грамматики допускают пустую цепочку в правой части правил. <br />
	Это означает, что мы можем иметь правила вида A → ε, где ε - пустая цепочка.<br />

	<strong>
		Пример КС-грамматики 
	</strong>
	Пусть у нас есть грамматика G(VT, VN, P, S), где:
	<pre>
    VT = (a, b, c) - терминальные символы
    VN = (S, A, B) - нетерминальные символы
    P - набор правил:
        S → AB
        A → aA | a
        B → bB | b
    S - начальный символ
	</pre>
	<strong>
		Укорачивающие КС-грамматики 
	</strong>
	Укорачивающие КС-грамматики допускают пустую цепочку в правой части правил. Это означает, <br/>
	что мы можем иметь правила вида A → ε, где ε - пустая цепочка. <br/>
	Например, если у нас есть грамматика G(VT, VN, P, S), где:
	<pre>
    VT = (a, b, c) - терминальные символы
    VN = (S, A, B) - нетерминальные символы
    P - набор правил:
        S → AB
        A → aA | a | ε
        B → bB | b
    S - начальный символ
	</pre>
	<div class="card w-96 bg-base-200 p-4">
		<p class="card-title">База про КС граматики</p>
		<div class="card-body">
			КС граматики позволяют генерировать цепочки символов вне зависимости от окружающих терминал символов.
			Это крайне удобно в применении, что позволяет без переусложнений использовать то что надо.
			Левая часть состоит из 1 нетерминала, а правая часть может содержать терминалы и нетерминалы <i>в любом порядке</i>
		</div>
	</div>

	<h3 class="mt-4 text-2xl font-semibold">Тип 3 – <u>Регулярные</u> грамматики</h3>
	<div>
		В правой части правил грамматик этого типа может присутствовать не<br/>
		<strong>более одного нетерминального символа</strong>, причём он должен быть<br/>
		расположен во всех правилах одной грамматики<strong> с одной и той же стороны</strong><br/>
		от цепочки терминалов, а требования к левой части правил совпадают с<br/>
		предыдущим типом. К этому типу относятся два эквивалентных класса<br/>
		грамматик: леволинейные и праволинейные (их название определяется<br/>
		местоположением нетерминального символа в правой части правил<br/>
		относительно терминальной цепочки).<br/>
	</div>
	<strong>
		Пример регулярной грамматики
	</strong>
	<pre>
	Пусть у нас есть грамматика G(VT, VN, P, S), где:

	VT = (a, b, c) - терминальные символы
	VN = (S, A, B) - нетерминальные символы
	P - набор правил:
		S → Aa
		A → Ab | a
		B → Bc | c
	S - начальный символ
	</pre>
	Эта грамматика является праволинейной, поскольку нетерминальный символ в<br/> 
	правой части правил всегда находится справа от цепочки терминалов.
	<h3 class="mt-4 text-2xl font-semibold">Классификация Языков</h3>

	<strong>Тип 0 – языки с фразовой структурой</strong>
Это самые сложные языки, для распознавания которых требуются
вычислители, равномощные машине Тьюринга. Для такого языка невозможно
построить компилятор, который выполнил бы разбор за ограниченное время
на основе ограниченных вычислительных ресурсов.
Практически все естественные языки относятся к этому типу. Одно и то
же слово в естественном языке может иметь различный смысл в зависимости
от контекста и играть различную роль в предложении. Такие языки далее
рассматриваться не будут.
	<strong>Тип 1 – контекстно-зависимые (КЗ) языки</strong>
В общем случае время на распознавание языка типа 1 экспоненциально
зависит от длины исходной цепочки символов.
Языки и грамматики этого типа используются в переводе текстов на
естественных языках. Распознаватели, построенные на их основе, позволяют
анализировать тексты с учётом контекстной зависимости в предложениях
входного языка, хотя в общем случае для точного перевода всё же требуется
вмешательство человека. Такие грамматики могут использоваться в
сервисных функциях проверки орфографии в языковых процессорах.
Однако языки программирования имеют более простую структуру,
поэтому в компиляторах КЗ-языки не применяются.
	<strong>Тип 2 – контекстно-свободные (КС) языки</strong>
КС-языки лежат в основе большинства современных языков
программирования, на их основе работают некоторые командные
процессоры, допускающие управляющие команды цикла и условия.
В общем случае время на распознавание предложений языка этого типа
полиномиально зависит от длины цепочки символов (это кубическая или
квадратичная зависимость в зависимости от класса языка). Но среди КС-
языков существует много классов, для которых эта зависимость линейна, и
многие языки программирования можно отнести к одному из таких классов.
	<strong>Тип 3 – регулярные языки</strong>
Это самый простой тип языков, и они являются наиболее широко
распространенным типом, используемым в вычислительных системах. Время
на распознавание цепочек языка линейно зависит от их длины. Поэтому
иногда эти языки ещё называют линейными. Для работы с такими языками
используются регулярные множества и выражения, конечные автоматы.
КС-языки и регулярные языки будут рассматриваться подробно.


</div>
